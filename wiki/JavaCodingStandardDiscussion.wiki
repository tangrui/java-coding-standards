#summary Contains more detailed content on standards highlight in the JavaCodingStandardsMatrix page.
#sidebar TableOfContents

<wiki:toc max_depth="5" />

= Code Organisation =

One of the first things we need to think about when starting to write our software is how we organise the source files for development. The way we organise our code is extremely important and will ultimately effect our goals of attaining code reuse and maintainability.

Typically the use of software changes over time. It needs to be able to respond to changing specifications. This means that a code base needs to be able to evolve and most likely needs to be able to cope with many different developers reading and changing code over the course of its life time. 

To support the evolving code base we discuss:
   * The *concept of a Module* and 
   * Java's *package* feature.

== Module ==

A *Module* is a conceptual term in Java. 

A Module should:

   * Be Highly Cohesion
   * Have Low Coupling with other modules
   * Support Re-Use
      * The Release Reuse Equivalency Principle (REP)

== Guiding Principles ==

When considering how to organise our project struture we take into account the following principles outlined in http://www.objectmentor.com/resources/articles/Principles_and_Patterns.pdf.

   * The Release Reuse Equivalency Principle (REP): The granule of reuse is the granule of release.
   * The Common Closure Principle (CCP): Classes that change together, belong together.
   * The Common Reuse Principle (CRP):  Classes that arenâ€™t reused together should not be grouped together.

We prefer to align projects with a deliverable artifact. That is if the piece of software is delivered as a jar file, then all the source code for that deliverable would exist in the one project. If the deliverable was two jar files, then it would make sense that the code was structure in two projects, each project responsible for storing and create its own jar file.

If there are specific parts of our system that we wish to be reusable we should structure the source into their own projects which are responsible for creating the deliverable (.jar, .war or .ear file) from the source.

=== Module Structure ===

Sun provide <a href="http://java.sun.com/blueprints/code/projectconventions.html">guidelines</a> for the project layout when building end-to-end java applications.

Maven advocates a <a href="http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html">project directory structure</a>

{{{
+[ProjectName]
|
----+ src
     |
     ----+ main 
     |   |
     |   ----+ java 
     |
     |----+ test
         |
         ----+ java
----+ lib
----+ target
}}}

   * All source code goes under src/main. The Java source specifically goes under src/main/java
   * All test code goes under src/test. The Java test code specifically goes under src/test/java
   * All dependencies jars goes under the lib folder.
   * All compiled files go under the target folders (with a split between test and production code as above).

=== Module Naming ===

The name of a 'project' or module should reveal what the source code contain within it is responsible for.

If you structure your source underneath one project, you may choose the name of the application/system it is.

We prefer to name our projects/modules with camel case and with capital letters for each word e.g Domain, or ExampleProjectName

At times we append on War or Ear to signify that this project is responsible for specifically storing WAR or EAR source code e.g ExampleApplicationWar, ExampleApplicationEar

If you have structured the source code into several modules or project you may choose to name them after architectural components of the system, ui, service, domain etc

== Packages ==

A package provides a unique namespace for the types (Classes, Interfaces, Enums, Annotations) it contains.

Packages are used to identify sub-systems of a software application. Types that are used together and change together that serve to implement a practicular behaviour are packaged together.